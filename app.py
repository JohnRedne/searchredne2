# -*- coding: utf-8 -*-
"""Untitled37.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12ltdYIH4U3gXuystpkRQUnaCYaHBlvnw
"""

from flask import Flask, request, jsonify, send_file
import urllib.request
import io
from obspy import read
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime
import os
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

def date_to_julian_day(date: str) -> int:
    """Convierte una fecha ISO8601 al día juliano del año."""
    dt = datetime.fromisoformat(date)
    start_of_year = datetime(dt.year, 1, 1)
    julian_day = (dt - start_of_year).days + 1
    return julian_day

@app.route('/generate_sismograma', methods=['GET'])
def generate_sismograma():
    try:
        # Obtener parámetros de la solicitud
        start = request.args.get('start')
        end = request.args.get('end')
        net = request.args.get('net')
        sta = request.args.get('sta')
        channels = ['HNE.D', 'HNN.D', 'HNZ.D']

        if not all([start, end, net, sta]):
            return jsonify({"error": "Faltan parámetros requeridos (start, end, net, sta)"}), 400

        # Convertir fecha de inicio al día juliano
        julian_day = date_to_julian_day(start)
        year = datetime.fromisoformat(start).year

        # Base URL
        base_url = f"http://osso.univalle.edu.co/apps/seiscomp/archive/{year}/{net}/{sta}"

        # Crear enlaces para los canales
        urls = {
            channel: f"{base_url}/{channel}/{net}.{sta}.00.{channel}.{year}.{julian_day}"
            for channel in channels
        }

        streams = {}

        # Paso 1: Descargar y leer los datos de cada canal
        for channel, url in urls.items():
            file_path = f"{channel}.mseed"
            try:
                print(f"Descargando el archivo {channel}...")
                urllib.request.urlretrieve(url, file_path)
                print(f"Archivo {channel} descargado con éxito.")

                # Leer el archivo MiniSEED
                streams[channel] = read(file_path)
                print(f"Información del archivo {channel}:")
                print(streams[channel][0].stats)  # Mostrar información básica de la estación

                # Eliminar el archivo temporal
                os.remove(file_path)

            except Exception as e:
                if os.path.exists(file_path):
                    os.remove(file_path)
                return jsonify({"error": f"Error procesando {channel}: {str(e)}"}), 500

        # Crear una figura para los gráficos
        fig, axes = plt.subplots(len(channels), 1, figsize=(12, 10))
        for idx, (channel, stream) in enumerate(streams.items()):
            trace = stream[0]

            # Recortar la señal entre los tiempos proporcionados
            start_time = trace.stats.starttime
            end_time = trace.stats.endtime
            st_trimmed = stream.slice(starttime=start_time, endtime=end_time)
            trace_trimmed = st_trimmed[0]

            axes[idx].plot(trace_trimmed.times("matplotlib"), trace_trimmed.data, label=f"Canal {channel}", linewidth=0.8, color="blue")
            axes[idx].set_title(f"Sismograma {channel} ({trace.stats.station})", fontsize=12)
            axes[idx].set_ylabel("Amplitud", fontsize=10)
            axes[idx].legend(loc="upper right")
            axes[idx].grid(True, linestyle="--", alpha=0.7)

            # Formatear el eje X para mostrar UTC
            axes[idx].xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S UTC'))
            axes[idx].set_xlabel("Tiempo (HH:MM:SS UTC)", fontsize=10)

        # Ajustar el diseño del gráfico
        plt.tight_layout()

        # Guardar la imagen en memoria y devolverla
        output_image = io.BytesIO()
        plt.savefig(output_image, format='png')
        output_image.seek(0)
        plt.close(fig)

        return send_file(output_image, mimetype='image/png')

    except Exception as e:
        return jsonify({"error": f"Ocurrió un error: {str(e)}"}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)









